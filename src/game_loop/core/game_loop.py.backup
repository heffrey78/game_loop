"""
Core game loop implementation for Game Loop.
Handles the main game loop, input processing, and output generation.
"""

import logging
from typing import Any
from uuid import UUID

import asyncpg
from rich.console import Console

from game_loop.config.manager import ConfigManager
from game_loop.config.models import GameConfig
from game_loop.core.actions.action_classifier import ActionTypeClassifier
from game_loop.core.command_handlers.factory import CommandHandlerFactory
from game_loop.core.enhanced_input_processor import EnhancedInputProcessor
from game_loop.core.input_processor import CommandType, InputProcessor, ParsedCommand
from game_loop.core.location import LocationDisplay
from game_loop.core.navigation.pathfinder import PathfindingService
from game_loop.core.navigation.validator import NavigationValidator
from game_loop.core.world.boundary_manager import WorldBoundaryManager
from game_loop.core.world.connection_graph import LocationConnectionGraph
from game_loop.core.world.dynamic_world_coordinator import DynamicWorldCoordinator
from game_loop.core.world.world_generation_pipeline import WorldGenerationPipeline
from game_loop.database.session_factory import DatabaseSessionFactory
from game_loop.llm.ollama.client import OllamaClient
from game_loop.state.manager import GameStateManager
from game_loop.state.models import ActionResult, Location, PlayerState, WorldState

logger = logging.getLogger(__name__)


class GameLoop:
    """Main game loop implementation for the Game Loop text adventure."""

    def __init__(
        self, config: GameConfig, db_pool: asyncpg.Pool, console: Console | None = None
    ):
        """
        Initialize the game loop with configuration and database pool.

        Args:
            config: Configuration for the game
            db_pool: Database connection pool
            console: Rich console for output, creates new one if not provided
        """
        self.config = config
        self.db_pool = db_pool
        self.console = console if console else Console()
        self.location_display = LocationDisplay(self.console)
        self.running = False

        # Initialize config manager for LLM with correct prompt template directory
        from pathlib import Path

        from game_loop.config.manager import ConfigManager as GameConfigManager

        self.config_manager = ConfigManager()
        self.game_config_manager = GameConfigManager(config_file=None)
        self.game_config_manager.config = config

        # Update the prompt template directory to point to our implementation
        project_root = Path(__file__).parent.parent.parent
        prompt_dir = project_root / "game_loop" / "llm" / "prompts"
        self.config_manager.config.prompts.template_dir = str(prompt_dir)

        # Initialize GameStateManager with the correct config manager type
        self.state_manager = GameStateManager(self.game_config_manager, self.db_pool)

        # Initialize database session factory
        self.session_factory = DatabaseSessionFactory(config.database)

        # Initialize LLM client
        self.ollama_client = OllamaClient()

        # Initialize action classifier
        self.action_classifier = ActionTypeClassifier(
            config_manager=self.config_manager,
            ollama_client=self.ollama_client,
        )

        # For now, initialize semantic search as None - will be set up properly later
        self.semantic_search = None

        # Create enhanced input processor with NLP capabilities
        self.input_processor = EnhancedInputProcessor(
            config_manager=self.config_manager,
            console=self.console,
            use_nlp=config.features.use_nlp,
            game_state_manager=self.state_manager,
        )

        # Fallback to basic input processor if needed
        self.basic_input_processor = InputProcessor(
            self.console,
            game_state_manager=self.state_manager,
        )

        # Initialize the command handler factory with all dependencies
        self.command_handler_factory = CommandHandlerFactory(
            console=self.console,
            state_manager=self.state_manager,
            session_factory=self.session_factory,
            config_manager=self.config_manager,
            llm_client=self.ollama_client,
            semantic_search=self.semantic_search,
            action_classifier=self.action_classifier,
        )

        # Initialize navigation components
        self.connection_graph = LocationConnectionGraph()
        self.boundary_manager: WorldBoundaryManager | None = None  # Will be initialized when world state is available
        self.navigation_validator = NavigationValidator(self.connection_graph)
        self.pathfinding_service: PathfindingService | None = None  # Will be initialized when world state is available
        
        # Initialize dynamic world generation system
        self.dynamic_world_coordinator: DynamicWorldCoordinator | None = None
        self.world_generation_pipeline: WorldGenerationPipeline | None = None

    async def initialize(self, session_id: UUID | None = None) -> None:
        """Initialize the game environment, loading or creating game state."""
        self.console.print("[bold green]Initializing Game Loop...[/bold green]")

        try:
            # Initialize database session factory
            await self.session_factory.initialize()

            # Initialize the state manager, attempting to load if session_id provided
            await self.state_manager.initialize(session_id)

            player_state: PlayerState | None = None
            world_state: WorldState | None = None

            if session_id:
                # Attempt to load the game
                player_state, world_state = await self.state_manager.load_game(
                    session_id
                )  # noqa: E501
                if player_state and world_state:
                    self.console.print(f"Loaded game session {session_id}.")
                else:
                    self.console.print(
                        f"[bold red]Failed to load game session "
                        f"{session_id}. Starting new game.[/bold red]"
                    )
                    session_id = None

            if not session_id:
                # Create a new game if no session ID or loading failed
                player_name = self._get_player_name()
                # TODO: Get save name, maybe from player input or default
                save_name = f"{player_name}'s Game"
                player_state, world_state = await self.state_manager.create_new_game(
                    player_name, save_name
                )

                if not player_state or not world_state:
                    raise RuntimeError("Failed to create a new game.")

                self.console.print(
                    f"\n[bold green]Welcome to the adventure, "
                    f"{player_state.name}![/bold green]\n"
                )
            else:
                # Welcome back message for loaded game
                if player_state:
                    self.console.print(
                        f"\n[bold green]Welcome back, "
                        f"{player_state.name}![/bold green]\n"
                    )

        except Exception as e:
            logger.exception(f"Error during game initialization: {e}")
            self.console.print(
                f"[bold red]Error initializing game: {e}. " f"Exiting.[/bold red]"
            )
            self.running = False
            return

        # Initial display depends on successful load/create
        if self.state_manager.get_current_session_id():
            # Initialize navigation components with world state
            await self._initialize_navigation_system()
            
            # Initialize dynamic world generation system
            await self._initialize_dynamic_world_system()
            
            await self._display_current_location()  # Use await
        else:
            self.console.print(
                "[bold red]Failed to initialize or load game state.[/bold red]"
            )  # noqa: E501
            self.running = False

    def stop(self) -> None:
        """Stop the game loop."""
        self.console.print("[bold]Farewell, adventurer! Your journey ends here.[/bold]")
        self.running = False

    async def _initialize_navigation_system(self) -> None:
        """Initialize the navigation system with current world state."""
        try:
            world_state = self.state_manager.world_tracker.get_state()
            if not world_state:
                logger.warning("No world state available for navigation initialization")
                return

            # Initialize boundary manager
            self.boundary_manager = WorldBoundaryManager(world_state)

            # Initialize pathfinding service
            self.pathfinding_service = PathfindingService(
                world_state, self.connection_graph
            )

            # Build the connection graph from world state
            await self._build_connection_graph(world_state)

            logger.info("Navigation system initialized successfully")

        except Exception as e:
            logger.error(f"Error initializing navigation system: {e}")
            
    async def _initialize_dynamic_world_system(self) -> None:
        """Initialize the dynamic world generation system."""
        try:
            world_state = self.state_manager.world_tracker.get_state()
            if not world_state:
                logger.warning("No world state available for dynamic world initialization")
                return

            # Initialize Jinja2 template environment for LLM prompts
            from jinja2 import Environment, FileSystemLoader
            from pathlib import Path
            
            template_dir = Path(__file__).parent.parent.parent / "templates" / "world_generation"
            template_env = Environment(loader=FileSystemLoader(str(template_dir)))

            # Initialize world generation pipeline
            # For now, we'll skip full pipeline initialization and use a placeholder
            # TODO: Initialize individual generators (LocationGenerator, NPCGenerator, etc.)
            self.world_generation_pipeline = None  # Temporarily disabled

            # Initialize dynamic world coordinator
            self.dynamic_world_coordinator = DynamicWorldCoordinator(
                world_state=world_state,
                session_factory=self.session_factory,
                llm_client=self.ollama_client,
                template_env=template_env
            )
            
            # Set the generation pipeline in the coordinator
            # Currently disabled until we implement individual generators
            # if self.dynamic_world_coordinator and self.world_generation_pipeline:
            #     self.dynamic_world_coordinator.set_generation_pipeline(self.world_generation_pipeline)

            logger.info("Dynamic world generation system initialized successfully")

        except Exception as e:
            logger.error(f"Error initializing dynamic world system: {e}")

    async def _build_connection_graph(self, world_state: WorldState) -> None:
        """Build the connection graph from world state."""
        try:
            # Clear existing graph
            self.connection_graph.clear()

            # Add all locations to graph
            for location_id, location in world_state.locations.items():
                self.connection_graph.add_location(
                    location_id,
                    {
                        "name": location.name,
                        "type": location.state_flags.get("type", "generic"),
                    },
                )

            # Add all connections
            for location_id, location in world_state.locations.items():
                for direction, destination_id in location.connections.items():
                    # Check if destination exists in world state
                    if destination_id in world_state.locations:
                        self.connection_graph.add_connection(
                            location_id,
                            destination_id,
                            direction,
                            bidirectional=False,  # Add each direction explicitly
                        )

            logger.info(
                f"Built connection graph with {self.connection_graph.get_location_count()} locations and {self.connection_graph.get_connection_count()} connections"
            )

        except Exception as e:
            logger.error(f"Error building connection graph: {e}")

    def _get_player_name(self) -> str:
        """Get a name for the player character."""
        self.console.print("\n[bold]Enter your character name:[/bold]")
        player_name = input("> ").strip()
        return player_name if player_name else "Adventurer"

    async def run(self) -> None:
        """Run the main game loop."""
        self.running = True

        # Display the initial location
        await self._display_current_location()

        while self.running:
            try:
                await self._process_input_async()
            except Exception as e:
                logger.exception(f"Unexpected error in game loop: {e}")
                self.console.print(f"[bold red]An error occurred: {e}[/bold red]")

        # When the loop ends, consider saving the game state automatically
        # await self._auto_save_game()

    async def _display_current_location(self) -> None:
        """Display the current location to the player using rich output."""
        location = await self.state_manager.get_current_location_details()
        if location:
            from game_loop.core.location import Location as OldLocation

            old_location = OldLocation(
                id=str(location.location_id),
                name=location.name,
                description=location.description,
            )

            # Add connections
            for direction, loc_id in location.connections.items():
                old_location.add_connection(direction, str(loc_id))

            # Add objects from the location
            for _obj_id, obj in location.objects.items():
                if not obj.is_hidden:
                    old_location.add_item(obj.name.lower().replace(" ", "_"))

            # Add NPCs as placeholder objects in the old format
            for _npc_id, npc in location.npcs.items():
                old_location.add_npc(npc.name.lower().replace(" ", "_"))

            # Now display the converted location
            self.location_display.display_location(old_location)
        else:
            self.console.print(
                "[bold red]Error: Current location not found.[/bold red]"
            )

    def _extract_game_context(self) -> dict[str, Any]:
        """
        Extract relevant game state as context for NLP processing.

        Returns:
            Dictionary containing game state context
        """
        context = {}
        player_state = self.state_manager.player_tracker.get_state()
        current_location_id = None
        current_location = None

        if player_state and player_state.current_location_id:
            current_location_id = player_state.current_location_id
            world_state = self.state_manager.world_tracker.get_state()
            if world_state:
                current_location = world_state.locations.get(current_location_id)

        if current_location:
            context["current_location"] = {
                "id": str(current_location.location_id),
                "name": current_location.name,
                "description": current_location.description,
            }

            # Add connections
            connections = {}
            for direction, dest_id in current_location.connections.items():
                if world_state:
                    dest_location = world_state.locations.get(dest_id)
                    if dest_location:
                        connections[f"connection_{direction}"] = (
                            f"{direction} to {dest_location.name}"
                        )
            context["connections"] = connections

            # Add visible objects from the current location
            visible_objects = {}
            for i, (_obj_id, obj) in enumerate(current_location.objects.items()):
                if not obj.is_hidden:
                    visible_objects[f"object_{i}"] = obj.name
            context["visible_objects"] = visible_objects

            # Add NPCs from the current location
            npcs = {}
            for i, (_npc_id, npc) in enumerate(current_location.npcs.items()):
                npcs[f"npc_{i}"] = npc.name
            context["npcs"] = npcs

        # Add player information
        if player_state:
            # Create player info with name and ID
            player_info = {
                "name": player_state.name,
                "player_id": (
                    str(player_state.player_id) if player_state.player_id else None
                ),
            }

            # Add inventory
            if player_state.inventory:
                player_info["inventory"] = ", ".join(
                    item.name for item in player_state.inventory
                )
            else:
                player_info["inventory"] = "empty"

            # Add knowledge and stats if available
            if player_state.knowledge:
                player_info["knowledge"] = ", ".join(
                    [k.content for k in player_state.knowledge]
                )

            if player_state.stats:
                # Convert PlayerStats object to dictionary by extracting its attributes
                stats_dict = {
                    "health": player_state.stats.health,
                    "max_health": player_state.stats.max_health,
                    "mana": player_state.stats.mana,
                    "max_mana": player_state.stats.max_mana,
                    "strength": player_state.stats.strength,
                    "dexterity": player_state.stats.dexterity,
                    "intelligence": player_state.stats.intelligence,
                }
                player_info["stats"] = str(stats_dict)

            context["player"] = player_info
            # Also add player_id at the top level for system commands
            context["player_id"] = (
                str(player_state.player_id) if player_state.player_id else None
            )

        return context

    def _process_input(self) -> None:
        """Process player input and execute appropriate actions.

        This is a synchronous wrapper around _process_input_async to maintain
        backward compatibility with existing tests that don't use await.
        """
        try:
            import asyncio

            # Use get_event_loop().run_until_complete() to handle the coroutine
            # in a synchronous context
            asyncio.get_event_loop().run_until_complete(self._process_input_async())
        except Exception as e:
            self.console.print(f"[bold red]Error processing input: {e}[/bold red]")

    async def _process_input_async(self) -> None:
        """Process player input and execute appropriate actions asynchronously."""
        self.console.print("\n[bold cyan]What would you like to do?[/bold cyan]")
        user_input = input("> ").strip()

        if not user_input:
            self.console.print("[yellow]Please enter a command.[/yellow]")
            return

        # Extract game context for NLP processing
        game_context = self._extract_game_context()

        # First check if this might be a movement command before checking system commands
        # This prevents "exit" from being treated as a quit command when it's a valid direction
        is_potential_movement = await self._is_potential_movement_command(user_input)
        
        
        if not is_potential_movement:
            # Check if this is a system command only if it's not a potential movement
            system_result = await self.command_handler_factory.handle_command(
                user_input, game_context
            )

            if system_result:
                # This was a system command, display the result
                if system_result.feedback_message:
                    self.console.print(system_result.feedback_message)

                # Check if this was a quit command and stop the game loop
                # But NOT if user typed "exit" and there's an exit direction available
                if user_input.lower().strip() in ["quit", "/quit", "/exit"] and user_input.lower().strip() != "exit":
                    self.stop()

                return
        else:
            # This is a potential movement command, so skip system command processing
            # and proceed directly to normal game command processing
            pass

        # Not a system command, process normally
        command = None

        try:
            # Process the input through the enhanced input processor
            command = await self.input_processor.process_input_async(
                user_input, game_context
            )

            # Update conversation context with this exchange
            response = "Command processed successfully."
            await self.input_processor.update_conversation_context(user_input, response)

        except Exception:
            self.console.print("[yellow]Using simplified input processing...[/yellow]")
            try:
                basic_processor = InputProcessor(self.console)
                command = await basic_processor.process_input_async(user_input)
            except Exception as inner_e:
                self.console.print(
                    f"[bold red]Input processing error: " f"{inner_e}[/bold red]"
                )
                return

        if command:
            await self._execute_command(command)

    async def _execute_command(self, command: ParsedCommand) -> ActionResult | None:
        """Execute a processed command and return ActionResult."""
        player_state = self.state_manager.player_tracker.get_state()
        await self.state_manager.player_tracker.get_current_location_id()
        current_location = await self.state_manager.get_current_location_details()
        world_state = self.state_manager.world_tracker.get_state()

        # Special handling: Convert QUIT to MOVEMENT if "exit" is a valid direction
        if (command.command_type == CommandType.QUIT and 
            current_location and 
            "exit" in current_location.connections):
            # Convert this quit command to a movement command
            command = ParsedCommand(
                command_type=CommandType.MOVEMENT,
                action="go",
                subject="exit"
            )

        # Verify required state exists before proceeding
        if not player_state:
            return ActionResult(
                success=False, feedback_message="Error: Player state not initialized."
            )

        if not current_location:
            return ActionResult(
                success=False,
                feedback_message="Error: Cannot determine current location.",
            )

        if not world_state:
            return ActionResult(
                success=False, feedback_message="Error: World state not initialized."
            )

        action_result = None
        try:
            if command.command_type == CommandType.MOVEMENT:
                if command.subject:
                    action_result = await self._handle_movement(
                        command.subject, player_state, current_location
                    )
                else:
                    action_result = ActionResult(
                        success=False, feedback_message="No direction specified."
                    )

            elif command.command_type == CommandType.LOOK:
                await self._display_current_location()
                # No state change, just visual output
                action_result = ActionResult(success=True, feedback_message="")

            elif command.command_type == CommandType.INVENTORY:
                await self._display_inventory(player_state)
                # No state change, just visual output
                action_result = ActionResult(success=True, feedback_message="")

            elif command.command_type == CommandType.TAKE:
                if command.subject:
                    action_result = await self._handle_take(
                        command.subject, player_state, current_location
                    )
                else:
                    action_result = ActionResult(
                        success=False, feedback_message="What do you want to take?"
                    )

            elif command.command_type == CommandType.DROP:
                if command.subject:
                    action_result = await self._handle_drop(
                        command.subject, player_state, current_location
                    )
                else:
                    action_result = ActionResult(
                        success=False, feedback_message="What do you want to drop?"
                    )

            elif command.command_type == CommandType.USE:
                # Use the command handler strategy pattern
                handler = self.command_handler_factory.get_handler(CommandType.USE)
                action_result = await handler.handle(command)

            elif command.command_type == CommandType.EXAMINE:
                if command.subject:
                    action_result = await self._handle_examine(
                        command.subject, player_state, current_location, world_state
                    )
                else:
                    action_result = ActionResult(
                        success=False, feedback_message="What do you want to examine?"
                    )

            elif command.command_type == CommandType.TALK:
                if command.subject:
                    action_result = await self._handle_talk(
                        command.subject, player_state, current_location
                    )
                else:
                    action_result = ActionResult(
                        success=False, feedback_message="Who do you want to talk to?"
                    )

            elif command.command_type == CommandType.HELP:
                self._display_help()
                # No state change, just visual output
                action_result = ActionResult(success=True, feedback_message="")

            elif command.command_type == CommandType.QUIT:
                # Possibly update state before shutting down
                action_result = ActionResult(
                    success=True,
                    feedback_message="Farewell, adventurer! Your journey ends here.",
                )
                self.stop()

            else:
                # Unknown command
                error_message = self.input_processor.format_error_message(command)
                action_result = ActionResult(
                    success=False, feedback_message=error_message
                )

        except Exception as e:
            logger.exception(f"Error executing command: {e}")
            action_result = ActionResult(
                success=False, feedback_message=f"Error: {str(e)}"
            )

        # If we have a result with a feedback message, display it
        if action_result and action_result.feedback_message:
            if action_result.success:
                self.console.print(f"[green]{action_result.feedback_message}[/green]")
            else:
                self.console.print(f"[yellow]{action_result.feedback_message}[/yellow]")

        # If the action was successful, update the game state
        if (
            action_result
            and action_result.success
            and (
                action_result.location_change
                or action_result.inventory_changes
                or action_result.object_changes
                or action_result.npc_changes
                or action_result.location_state_changes
                or action_result.knowledge_updates
                or action_result.stat_changes
                or action_result.progress_updates
                or action_result.triggers_evolution
            )
        ):
            await self.state_manager.update_after_action(action_result)
            
            # Process dynamic world generation based on player action
            if self.dynamic_world_coordinator and player_state:
                try:
                    world_generation_response = await self.dynamic_world_coordinator.process_player_action(
                        action_result, player_state
                    )
                    
                    # Handle any generated content
                    if world_generation_response.has_new_content:
                        # Integrate generated content into the world
                        await self._integrate_generated_content(world_generation_response)
                        
                        # Inform player about new content discovery
                        if world_generation_response.generated_content:
                            content_count = len(world_generation_response.generated_content)
                            self.console.print(f"[dim cyan]The world around you seems to shift and change... ({content_count} new elements discovered)[/dim cyan]")
                        
                except Exception as e:
                    logger.error(f"Error processing dynamic world generation: {e}")
                    # Don't interrupt gameplay for generation errors

            # If the location changed, display the new location
            if action_result.location_change:
                self.console.print("")  # Add a line break
                await self._display_current_location()

        return action_result

    async def _handle_movement(
        self,
        direction: str,
        player_state: PlayerState,
        current_location: Location | None,
    ) -> ActionResult:
        """Handle movement in a given direction, returning ActionResult."""
        if not current_location:
            return ActionResult(
                success=False,
                feedback_message="Error: Cannot determine current location.",
            )

        # Normalize direction (e.g., "n" -> "north")
        direction_map = {"n": "north", "s": "south", "e": "east", "w": "west"}
        normalized_direction = direction_map.get(direction.lower(), direction.lower())

        # Check if movement is possible in the given direction
        destination_id = current_location.connections.get(normalized_direction)
        if not destination_id:
            # Try dynamic world generation for the missing direction
            new_destination = await self._attempt_dynamic_expansion(
                current_location, normalized_direction, player_state
            )
            
            if new_destination:
                destination_id = new_destination
                self.console.print(f"[dim cyan]As you move {normalized_direction}, the path ahead materializes...[/dim cyan]")
            else:
                return ActionResult(
                    success=False,
                    feedback_message=f"You cannot go {normalized_direction} from here.",
                )
        elif str(destination_id) == '00000000-0000-0000-0000-000000000000':
            # This is a placeholder connection - generate the actual location
            new_destination = await self._attempt_dynamic_expansion(
                current_location, normalized_direction, player_state
            )
            
            if new_destination:
                destination_id = new_destination
                self.console.print(f"[dim cyan]As you explore {normalized_direction}, a new area unfolds before you...[/dim cyan]")
            else:
                return ActionResult(
                    success=False,
                    feedback_message=f"The path {normalized_direction} seems to lead nowhere.",
                )

        # Use navigation validator if available
        if self.navigation_validator:
            try:
                validation_result = await self.navigation_validator.validate_movement(
                    player_state, current_location, destination_id, normalized_direction
                )

                if not validation_result.success:
                    return ActionResult(
                        success=False, feedback_message=validation_result.message
                    )
            except Exception as e:
                logger.warning(f"Navigation validation failed: {e}")
                # Continue with basic movement if validation fails

        # Create ActionResult with location change
        return ActionResult(
            success=True,
            feedback_message=f"You go {normalized_direction}.",
            location_change=True,
            new_location_id=destination_id,
        )

    async def _display_inventory(self, player_state: PlayerState) -> None:
        """Display the player's inventory."""
        if not player_state:
            self.console.print(
                "[bold red]Error: Player state not initialized.[/bold red]"
            )
            return

        inventory = player_state.inventory

        self.console.print("[bold]Inventory:[/bold]")
        if not inventory:
            self.console.print("Your inventory is empty.")
            return

        for item in inventory:
            self.console.print(f"- {item.name} ({item.quantity})")
            if item.description:
                self.console.print(f"  {item.description}")

    async def _handle_take(
        self,
        item_name: str,
        player_state: PlayerState,
        current_location: Location | None,
    ) -> ActionResult:
        """Handle taking an item from the current location, returning ActionResult."""
        if not current_location:
            return ActionResult(
                success=False,
                feedback_message="Error: Cannot determine current location.",
            )

        # Normalize item name
        normalized_item_name = item_name.replace("the ", "").strip().lower()

        # Find the item in the current location
        item_to_take = None
        item_id = None
        for obj_id, obj in current_location.objects.items():
            if obj.name.lower() == normalized_item_name and obj.is_takeable:
                item_to_take = obj
                item_id = obj_id
                break

        if not item_to_take:
            return ActionResult(
                success=False,
                feedback_message=f"You don't see any takeable {item_name} here.",
            )

        # Create an inventory item from the world object
        from game_loop.state.models import InventoryItem

        inventory_item = InventoryItem(
            name=item_to_take.name,
            description=item_to_take.description,
            attributes=item_to_take.state.get("attributes", {}),
        )

        # Define changes to be applied
        inventory_add = {"action": "add", "item": inventory_item.model_dump()}
        object_remove = {
            "action": "remove",
            "object_id": item_id,
            "location_id": current_location.location_id,
        }

        return ActionResult(
            success=True,
            feedback_message=f"You take the {item_to_take.name}.",
            inventory_changes=[inventory_add],
            object_changes=[object_remove],
        )

    async def _handle_drop(
        self,
        item_name: str,
        player_state: PlayerState,
        current_location: Location | None,
    ) -> ActionResult:
        """Handle dropping an item, returning ActionResult."""
        if not current_location:
            return ActionResult(
                success=False,
                feedback_message="Error: Cannot determine current location.",
            )

        normalized_item_name = item_name.replace("the ", "").strip().lower()

        # Find item in player's inventory
        item_to_drop = None
        for item in player_state.inventory:
            if item.name.lower() == normalized_item_name:
                item_to_drop = item
                break

        if not item_to_drop:
            return ActionResult(
                success=False, feedback_message=f"You don't have a {item_name}."
            )

        # Create a WorldObject representation of the dropped item
        from game_loop.state.models import WorldObject

        dropped_object = WorldObject(
            name=item_to_drop.name,
            description=item_to_drop.description,
            is_takeable=True,
            state={"attributes": item_to_drop.attributes},
        )

        # Define changes for ActionResult
        inventory_remove = {"action": "remove", "item_id": item_to_drop.item_id}
        object_add = {
            "action": "add",
            "location_id": current_location.location_id,
            "object": dropped_object.model_dump(),
        }

        return ActionResult(
            success=True,
            feedback_message=f"You drop the {item_to_drop.name}.",
            inventory_changes=[inventory_remove],
            object_changes=[object_add],
        )

    async def _handle_examine(
        self,
        object_name: str,
        player_state: PlayerState,
        current_location: Location | None,
        world_state: WorldState,
    ) -> ActionResult:
        """Handle examining an object, returning ActionResult."""
        if not current_location:
            return ActionResult(
                success=False,
                feedback_message="Error: Cannot determine current location.",
            )

        normalized_object_name = object_name.replace("the ", "").strip().lower()

        # Handle "examine here" or "look"
        if normalized_object_name == "here" or normalized_object_name == "around":
            await self._display_current_location()
            return ActionResult(success=True, feedback_message="")

        # Handle "look in/inside X"
        looking_inside = False
        container_name = normalized_object_name
        if normalized_object_name.startswith(
            "in "
        ) or normalized_object_name.startswith("inside "):
            prefix = "in " if normalized_object_name.startswith("in ") else "inside "
            container_name = normalized_object_name[len(prefix) :].strip()
            looking_inside = True

        target_object = None
        target_location_type = None

        # 1. Check player inventory
        for item in player_state.inventory:
            if item.name.lower() == container_name:
                target_object = item
                target_location_type = "inventory"
                break

        # 2. Check location objects if not found
        if not target_object:
            for _obj_id, obj in current_location.objects.items():
                if obj.name.lower() == container_name:
                    target_object = obj
                    target_location_type = "location_object"
                    break

        # 3. Check location NPCs if not found
        if not target_object:
            for _npc_id, npc in current_location.npcs.items():
                if npc.name.lower() == container_name:
                    target_object = npc
                    target_location_type = "location_npc"
                    break

        if not target_object:
            return ActionResult(
                success=False,
                feedback_message=f"You don't see any '{object_name}' here.",
            )

        # --- Handle Looking Inside ---
        if looking_inside:
            is_container = False
            contents = []
            if target_location_type == "inventory":
                is_container = target_object.attributes.get("is_container", False)
                contents = target_object.attributes.get("contained_items", [])
            elif target_location_type == "location_object":
                is_container = target_object.is_container
                contents = target_object.contained_items

            if not is_container:
                return ActionResult(
                    success=False,
                    feedback_message=f"The {target_object.name} is not a container.",
                )

            if not contents:
                return ActionResult(
                    success=True, feedback_message=f"The {target_object.name} is empty."
                )
            else:
                # For simplicity, just use UUIDs
                contents_str = ", ".join(
                    f"item {str(uuid)[:8]}..." for uuid in contents
                )
                return ActionResult(
                    success=True,
                    feedback_message=f"Inside the {target_object.name}"
                    f", you find: {contents_str}",
                )

        # --- Handle Regular Examination ---
        else:
            description = target_object.description

            # Add more details for objects or NPCs with state
            if hasattr(target_object, "state") and target_object.state:
                state_desc = ", ".join(
                    f"{k}: {v}"
                    for k, v in target_object.state.items()
                    if k != "attributes"
                )
                if state_desc:
                    description += f" ({state_desc})"

            return ActionResult(success=True, feedback_message=description)

    async def _handle_talk(
        self,
        character_name: str,
        player_state: PlayerState,
        current_location: Location | None,
    ) -> ActionResult:
        """Handle talking to an NPC, returning ActionResult."""
        if not current_location:
            return ActionResult(
                success=False,
                feedback_message="Error: Cannot determine current location.",
            )

        normalized_name = (
            character_name.replace("to ", "").replace("with ", "").strip().lower()
        )

        # Check if the NPC exists in the current location
        target_npc = None
        npc_id = None
        for n_id, npc in current_location.npcs.items():
            if npc.name.lower() == normalized_name:
                target_npc = npc
                npc_id = n_id
                break

        if not target_npc:
            return ActionResult(
                success=False,
                feedback_message=f"You don't see anyone called "
                f"'{character_name}' here.",
            )

        # For now, just provide a simple response based on NPC state
        dialogue_state = target_npc.dialogue_state
        if dialogue_state == "friendly":
            response = (
                f"{target_npc.name} smiles at you warmly. "
                f"'Hello there! How can I help you?'"
            )
        elif dialogue_state == "hostile":
            response = (
                f"{target_npc.name} glares at you suspiciously. 'What do you want?'"
            )
        else:  # neutral or default
            response = f"{target_npc.name} nods politely. 'Greetings, traveler.'"

        # In a full implementation, we'd use NLP to generate dialogue based on:
        # - NPC's knowledge
        # - Player's previous interactions
        # - Current world state
        # - NPC's personality

        # We might also add knowledge gained from the conversation:
        knowledge_gained = None
        from game_loop.state.models import PlayerKnowledge

        if hasattr(target_npc, "knowledge") and target_npc.knowledge:
            if not target_npc.state.get("hostile", False):
                # Give the player a random piece of knowledge the NPC has (simplified)
                import random

                if random.random() < 0.3:  # 30% chance
                    knowledge_item = random.choice(target_npc.knowledge)
                    # Create a new PlayerKnowledge object
                    new_knowledge = PlayerKnowledge(
                        content=knowledge_item.content,
                        source=f"conversation with {target_npc.name}",
                        topic=(
                            knowledge_item.topic
                            if hasattr(knowledge_item, "topic")
                            else "general"
                        ),
                    )
                    knowledge_gained = [new_knowledge]
                    response += f" '{knowledge_item.content}'"

        # Return ActionResult with conversation outcome
        return ActionResult(
            success=True,
            feedback_message=response,
            knowledge_updates=knowledge_gained,
            npc_changes=(
                [{"npc_id": npc_id, "update": {"state.talked_to": True}}]
                if npc_id
                else None
            ),
        )

    def _display_help(self) -> None:
        """Display available commands."""
        self.console.print("\n[bold]Game Commands:[/bold]")
        self.console.print(
            "- [bold]go/move[/bold] <direction>: "
            "Move in a direction (north, south, east, west, etc.)"
        )
        self.console.print("- [bold]look[/bold]: Look around the current location")
        self.console.print("- [bold]examine[/bold] <object>: Look closely at an object")
        self.console.print("- [bold]inventory/i[/bold]: Check your inventory")
        self.console.print("- [bold]take/get[/bold] <item>: Pick up an item")
        self.console.print(
            "- [bold]drop[/bold] <item>: Drop an item from your inventory"
        )
        self.console.print(
            "- [bold]use[/bold] <item> [on <target>]: "
            "Use an item, optionally on a target"
        )
        self.console.print("- [bold]talk[/bold] to <character>: Talk to a character")

        self.console.print("\n[bold]System Commands:[/bold]")
        self.console.print(
            "- [bold]save[/bold] [name]: Save your game (optionally with a name)"
        )
        self.console.print("- [bold]load[/bold] [name]: Load a saved game")
        self.console.print("- [bold]list saves[/bold]: Show all your saved games")
        self.console.print("- [bold]settings[/bold]: View or modify game settings")
        self.console.print(
            "- [bold]help[/bold] [topic]: Show help (optionally for a specific topic)"
        )
        self.console.print("- [bold]tutorial[/bold]: Get tutorial guidance")
        self.console.print("- [bold]quit/exit[/bold]: Quit the game")

    async def _integrate_generated_content(self, world_generation_response: Any) -> None:
        """Integrate generated content into the world state."""
        try:
            from game_loop.state.models import Location, NonPlayerCharacter, WorldObject
            
            world_state = self.state_manager.world_tracker.get_state()
            if not world_state:
                logger.warning("No world state available for content integration")
                return
            
            for content_data in world_generation_response.generated_content:
                content_type = content_data.get("type", "unknown")
                content = content_data.get("content", {})
                
                if content_type == "location":
                    # Create new location from generated content
                    new_location = Location(
                        name=content.get("name", "Mysterious Place"),
                        description=content.get("description", "A place of mystery."),
                        state_flags=content.get("state_flags", {})
                    )
                    world_state.locations[new_location.location_id] = new_location
                    
                elif content_type == "npc":
                    # Add NPC to appropriate location
                    location_id = content.get("location_id")
                    if location_id and location_id in world_state.locations:
                        new_npc = NonPlayerCharacter(
                            name=content.get("name", "Mysterious Figure"),
                            description=content.get("description", "A mysterious figure."),
                            dialogue_state=content.get("dialogue_state", "neutral")
                        )
                        world_state.locations[location_id].npcs[new_npc.npc_id] = new_npc
                        
                elif content_type == "object":
                    # Add object to appropriate location
                    location_id = content.get("location_id")
                    if location_id and location_id in world_state.locations:
                        new_object = WorldObject(
                            name=content.get("name", "Mysterious Object"),
                            description=content.get("description", "A mysterious object."),
                            is_takeable=content.get("is_takeable", False),
                            is_container=content.get("is_container", False)
                        )
                        world_state.locations[location_id].objects[new_object.object_id] = new_object
                        
                elif content_type == "connection":
                    # Add connection between locations
                    from_location_id = content.get("from_location_id")
                    to_location_id = content.get("to_location_id")
                    direction = content.get("direction")
                    
                    if (from_location_id and to_location_id and direction and 
                        from_location_id in world_state.locations and 
                        to_location_id in world_state.locations):
                        
                        world_state.locations[from_location_id].connections[direction] = to_location_id
                        
                        # Add reverse connection if specified
                        reverse_direction = content.get("reverse_direction")
                        if reverse_direction:
                            world_state.locations[to_location_id].connections[reverse_direction] = from_location_id
            
            # Update the world state in the state manager
            # Note: Need to implement set_state method in WorldStateTracker
            # For now, we'll just log that we integrated content
            logger.info("Content integrated successfully")
            
            # Rebuild connection graph for navigation
            if self.connection_graph:
                await self._build_connection_graph(world_state)
                
            logger.info(f"Integrated {len(world_generation_response.generated_content)} pieces of generated content")
            
        except Exception as e:
            logger.error(f"Error integrating generated content: {e}")

    async def _is_potential_movement_command(self, user_input: str) -> bool:
        """
        Check if the user input could be a movement command.
        
        Args:
            user_input: The user's input string
            
        Returns:
            True if this could be a movement command, False otherwise
        """
        try:
            # Get current location to check available directions
            current_location = await self.state_manager.get_current_location_details()
            if not current_location:
                return False
            
            # Parse the input to extract potential direction
            input_lower = user_input.lower().strip()
            
            # Handle movement patterns: "go <direction>", "move <direction>", or just "<direction>"
            potential_directions = []
            
            if input_lower.startswith(("go ", "move ", "walk ", "head ")):
                # Extract direction after movement verb
                parts = input_lower.split()
                if len(parts) > 1:
                    potential_directions.append(parts[1])
            else:
                # Direct direction command
                potential_directions.append(input_lower)
            
            # Check if any potential direction matches available connections
            available_directions = set(current_location.connections.keys())
            
            for direction in potential_directions:
                if direction in available_directions:
                    return True
                    
                # Also check direction abbreviations
                direction_map = {
                    "n": "north", "s": "south", "e": "east", "w": "west",
                    "ne": "northeast", "nw": "northwest", "se": "southeast", "sw": "southwest",
                    "u": "up", "d": "down"
                }
                
                full_direction = direction_map.get(direction, direction)
                if full_direction in available_directions:
                    return True
            
            return False
            
        except Exception as e:
            # If there's any error, err on the side of allowing normal processing
            logger.warning(f"Error checking movement command: {e}")
            return False

    async def _attempt_dynamic_expansion(
        self, current_location: Location, direction: str, player_state: PlayerState
    ) -> UUID | None:
        """
        Attempt to dynamically generate a new location in the specified direction.
        
        Args:
            current_location: The current location
            direction: The direction the player wants to go
            player_state: Current player state
            
        Returns:
            UUID of the new location if generation succeeds, None otherwise
        """
        try:
            # Check if this location can expand (either predefined or dynamically generated)
            can_expand = await self._can_location_expand(current_location, direction)
            if not can_expand:
                return None
            
            # Determine the type of location to generate
            location_type = await self._determine_location_type(current_location, direction)
            if not location_type:
                return None
                
            # Generate a new location with multiple exits
            new_location_id = await self._generate_enhanced_location(
                current_location, direction, location_type
            )
            
            if new_location_id:
                # Add bidirectional connection
                await self._add_connection(current_location.location_id, new_location_id, direction)
                
                # Generate additional exits for the new location
                await self._generate_additional_exits(new_location_id, current_location, direction)
                
                # Rebuild connection graph for navigation
                world_state = self.state_manager.world_tracker.get_state()
                if world_state and self.connection_graph:
                    await self._build_connection_graph(world_state)
                
                return new_location_id
                
            return None
            
        except Exception as e:
            logger.error(f"Error attempting dynamic expansion: {e}")
            return None

    async def _can_location_expand(self, location: Location, direction: str) -> bool:\n        \"\"\"\n        Check if a location can expand in the given direction.\n        \n        Args:\n            location: The location to check\n            direction: The direction of expansion\n            \n        Returns:\n            True if expansion is possible, False otherwise\n        \"\"\"\n        try:\n            # Check for predefined expansion opportunities\n            expansion_opportunities = {\n                \"Building Lobby\": [\"outside\", \"north\", \"south\", \"loading\"],\n                \"Emergency Stairwell\": [\"up\", \"north\", \"south\"],\n                \"Underground Parking Garage\": [\"down\", \"east\", \"maintenance\"],\n                \"Office\": [\"east\", \"west\", \"north\", \"south\"],\n                \"Conference Room\": [\"east\", \"west\", \"north\", \"south\"],\n                \"Reception Area\": [\"east\", \"west\", \"north\", \"south\"],\n                \"Break Room\": [\"east\", \"west\", \"north\", \"south\"],\n                \"Storage Room\": [\"east\", \"west\", \"north\", \"south\"]\n            }\n            \n            # Check if this is a predefined boundary location\n            location_name = location.name\n            if location_name in expansion_opportunities:\n                return direction in expansion_opportunities[location_name]\n            \n            # Check if this is a dynamically generated location that can expand\n            # Look for expansion metadata in location state\n            expansion_depth = location.state_flags.get(\"expansion_depth\", 0)\n            max_expansion_depth = 5  # Prevent infinite expansion\n            \n            if expansion_depth < max_expansion_depth:\n                # Check if location has expandable characteristics\n                location_type = location.state_flags.get(\"location_type\", \"unknown\")\n                \n                # Dynamic locations can generally expand in logical directions\n                if location.state_flags.get(\"is_dynamic\", False):\n                    return self._is_logical_direction(location_type, direction)\n            \n            return False\n            \n        except Exception as e:\n            logger.error(f\"Error checking if location can expand: {e}\")\n            return False\n    \n    def _is_logical_direction(self, location_type: str, direction: str) -> bool:\n        \"\"\"\n        Check if a direction makes logical sense for a location type.\n        \n        Args:\n            location_type: The type of location\n            direction: The direction to check\n            \n        Returns:\n            True if the direction is logical, False otherwise\n        \"\"\"\n        logical_directions = {\n            \"urban_street\": [\"north\", \"south\", \"east\", \"west\", \"inside\"],\n            \"industrial_district\": [\"north\", \"south\", \"east\", \"west\", \"inside\", \"down\"],\n            \"basement_access\": [\"north\", \"south\", \"east\", \"west\", \"down\"],\n            \"upper_floor\": [\"north\", \"south\", \"east\", \"west\", \"up\", \"down\"],\n            \"mechanical_room\": [\"north\", \"south\", \"east\", \"west\", \"maintenance\"],\n            \"sublevel\": [\"north\", \"south\", \"east\", \"west\", \"down\", \"maintenance\"],\n            \"industrial_zone\": [\"north\", \"south\", \"east\", \"west\", \"loading\"],\n            \"loading_dock\": [\"north\", \"south\", \"east\", \"west\", \"outside\"],\n            \"utility_tunnels\": [\"north\", \"south\", \"east\", \"west\", \"maintenance\", \"up\"],\n            \"roof_access\": [\"north\", \"south\", \"east\", \"west\", \"down\"]\n        }\n        \n        return direction in logical_directions.get(location_type, [\"north\", \"south\", \"east\", \"west\"])\n    \n    async def _determine_location_type(self, source_location: Location, direction: str) -> str | None:\n        \"\"\"\n        Determine what type of location should be generated.\n        \n        Args:\n            source_location: The location expanding from\n            direction: The direction of expansion\n            \n        Returns:\n            The type of location to generate, or None if no suitable type\n        \"\"\"\n        try:\n            # Predefined expansion mapping\n            expansion_mapping = {\n                \"Building Lobby\": {\n                    \"outside\": \"urban_street\",\n                    \"north\": \"industrial_district\", \n                    \"south\": \"basement_access\",\n                    \"loading\": \"loading_dock\"\n                },\n                \"Emergency Stairwell\": {\n                    \"up\": \"upper_floor\",\n                    \"north\": \"mechanical_room\",\n                    \"south\": \"roof_access\"\n                },\n                \"Underground Parking Garage\": {\n                    \"down\": \"sublevel\",\n                    \"east\": \"industrial_zone\",\n                    \"maintenance\": \"utility_tunnels\"\n                }\n            }\n            \n            # Check for predefined mapping\n            location_name = source_location.name\n            if location_name in expansion_mapping:\n                return expansion_mapping[location_name].get(direction)\n            \n            # For dynamic locations, generate based on context\n            source_type = source_location.state_flags.get(\"location_type\", \"unknown\")\n            \n            # Context-aware generation based on source type and direction\n            type_transitions = {\n                \"urban_street\": {\n                    \"north\": \"urban_street\", \"south\": \"urban_street\", \n                    \"east\": \"urban_street\", \"west\": \"urban_street\",\n                    \"inside\": \"building_interior\"\n                },\n                \"industrial_district\": {\n                    \"north\": \"industrial_zone\", \"south\": \"industrial_zone\",\n                    \"east\": \"industrial_zone\", \"west\": \"industrial_zone\",\n                    \"inside\": \"factory_interior\", \"down\": \"industrial_sublevel\"\n                },\n                \"basement_access\": {\n                    \"north\": \"basement_corridor\", \"south\": \"basement_corridor\",\n                    \"east\": \"basement_corridor\", \"west\": \"basement_corridor\",\n                    \"down\": \"sublevel\"\n                },\n                \"upper_floor\": {\n                    \"north\": \"office_space\", \"south\": \"office_space\",\n                    \"east\": \"office_space\", \"west\": \"office_space\",\n                    \"up\": \"executive_floor\", \"down\": \"lower_floor\"\n                }\n            }\n            \n            transitions = type_transitions.get(source_type, {})\n            return transitions.get(direction, \"unknown_area\")\n            \n        except Exception as e:\n            logger.error(f\"Error determining location type: {e}\")\n            return None\n    \n    async def _generate_enhanced_location(\n        self, source_location: Location, direction: str, location_type: str\n    ) -> UUID | None:\n        \"\"\"\n        Generate an enhanced location with expansion metadata.\n        \n        Args:\n            source_location: The source location\n            direction: Direction of expansion\n            location_type: Type of location to generate\n            \n        Returns:\n            UUID of the new location if successful, None otherwise\n        \"\"\"\n        try:\n            from uuid import uuid4\n            from game_loop.state.models import Location as LocationModel\n            \n            # Enhanced location templates with multiple exit hints\n            location_templates = {\n                \"urban_street\": {\n                    \"name\": \"Abandoned Street\",\n                    \"description\": \"A desolate urban street stretches before you, lined with empty storefronts and broken streetlights. Debris litters the asphalt, and the silence is unsettling. Streets continue in multiple directions, and you can see various building entrances along the sidewalks.\"\n                },\n                \"industrial_district\": {\n                    \"name\": \"Industrial District\",\n                    \"description\": \"You emerge into a sprawling industrial complex filled with massive machinery and conveyor systems. Steam hisses from pipes overhead, and the air thrums with the sound of distant generators. Multiple pathways lead to different sections of the industrial complex.\"\n                },\n                \"basement_access\": {\n                    \"name\": \"Basement Corridor\",\n                    \"description\": \"A narrow concrete corridor extends in multiple directions, lit by flickering fluorescent strips. You can hear the hum of electrical systems and the drip of water from unseen leaks. Several passages branch off, leading deeper into the building's underground network.\"\n                },\n                \"upper_floor\": {\n                    \"name\": \"Upper Office Floor\",\n                    \"description\": \"This higher floor contains executive offices and conference rooms, all abandoned but better preserved than the lower levels. Large windows show the city beyond, while multiple corridors lead to different wings of the floor.\"\n                },\n                \"mechanical_room\": {\n                    \"name\": \"Mechanical Room\",\n                    \"description\": \"A room filled with building systems: massive HVAC units, electrical panels, and cooling systems. The mechanical sounds are louder here, and you can see maintenance walkways leading to other parts of the building's infrastructure.\"\n                },\n                \"sublevel\": {\n                    \"name\": \"Sub-Basement\",\n                    \"description\": \"This lower level contains building utilities and storage areas. The ceiling is lower here, supported by concrete pillars. Multiple tunnels branch off in different directions, possibly connecting to other buildings or the city's utility network.\"\n                },\n                \"industrial_zone\": {\n                    \"name\": \"Industrial Processing Area\",\n                    \"description\": \"A large space filled with industrial equipment and processing machinery. Conveyor belts and assembly stations stretch across the floor. Various exits lead to other processing areas and what appears to be different industrial sectors.\"\n                },\n                \"loading_dock\": {\n                    \"name\": \"Loading Dock\",\n                    \"description\": \"A concrete platform where trucks once loaded and unloaded cargo. Large rolling doors face outward toward what was once a busy industrial area. Multiple truck bays and pathways lead to other logistics areas.\"\n                },\n                \"utility_tunnels\": {\n                    \"name\": \"Utility Tunnels\",\n                    \"description\": \"Underground maintenance tunnels that run beneath the building complex. Pipes and electrical conduits line the walls, and you can hear the echo of your footsteps. The tunnels branch in multiple directions, likely connecting to other buildings.\"\n                },\n                \"roof_access\": {\n                    \"name\": \"Rooftop Access\",\n                    \"description\": \"You emerge onto a rooftop area with HVAC equipment and communication arrays. The view shows the surrounding industrial district and urban landscape. Multiple maintenance walkways connect to other building sections.\"\n                },\n                \"building_interior\": {\n                    \"name\": \"Building Interior\",\n                    \"description\": \"The interior of an abandoned building with multiple rooms and corridors. Dust motes dance in shafts of light from broken windows. You can see doorways leading to different sections of the building.\"\n                },\n                \"factory_interior\": {\n                    \"name\": \"Factory Floor\",\n                    \"description\": \"A vast factory floor with abandoned assembly lines and industrial equipment. The space echoes with your footsteps, and you can see multiple work areas and passages leading to different parts of the facility.\"\n                },\n                \"basement_corridor\": {\n                    \"name\": \"Basement Corridor\",\n                    \"description\": \"A long underground corridor with concrete walls and exposed pipes overhead. Emergency lighting casts eerie shadows, and you can see multiple branching passages leading to different areas of the basement complex.\"\n                },\n                \"office_space\": {\n                    \"name\": \"Office Complex\",\n                    \"description\": \"An abandoned office space with cubicles and workstations covered in dust. Papers are scattered on desks, and you can see hallways leading to different departments and office areas.\"\n                },\n                \"unknown_area\": {\n                    \"name\": \"Mysterious Area\",\n                    \"description\": \"A strange area that defies easy description. The space seems to shift and change as you look at it, with passages leading in directions that shouldn't be possible.\"\n                }\n            }\n            \n            template = location_templates.get(location_type, location_templates[\"unknown_area\"])\n            \n            new_location_id = uuid4()\n            \n            # Calculate expansion depth\n            source_depth = source_location.state_flags.get(\"expansion_depth\", 0)\n            new_depth = source_depth + 1\n            \n            # Add to database with expansion metadata\n            async with self.db_pool.acquire() as conn:\n                await conn.execute(\n                    \"\"\"\n                    INSERT INTO locations (id, name, short_desc, full_desc, location_type, is_dynamic, created_by, state_json)\n                    VALUES ($1, $2, $3, $4, $5, $6, $7, $8)\n                    \"\"\",\n                    new_location_id,\n                    template[\"name\"],\n                    f\"A dynamically generated {location_type.replace('_', ' ')}\",\n                    template[\"description\"],\n                    \"dynamic\",\n                    True,  # is_dynamic\n                    \"dynamic_generation\",\n                    f'{{\"expansion_depth\": {new_depth}, \"location_type\": \"{location_type}\", \"is_dynamic\": true, \"can_expand\": true}}'\n                )\n            \n            # Add to world state\n            world_state = self.state_manager.world_tracker.get_state()\n            if world_state:\n                new_location = LocationModel(\n                    location_id=new_location_id,\n                    name=template[\"name\"],\n                    description=template[\"description\"],\n                    state_flags={\n                        \"expansion_depth\": new_depth,\n                        \"location_type\": location_type,\n                        \"is_dynamic\": True,\n                        \"can_expand\": True\n                    }\n                )\n                world_state.locations[new_location_id] = new_location\n            \n            logger.info(f\"Generated enhanced location: {template['name']} ({new_location_id}) at depth {new_depth}\")\n            return new_location_id\n            \n        except Exception as e:\n            logger.error(f\"Error generating enhanced location: {e}\")\n            return None\n    \n    async def _generate_additional_exits(\n        self, location_id: UUID, source_location: Location, entry_direction: str\n    ) -> None:\n        \"\"\"\n        Generate additional exits for a newly created location.\n        \n        Args:\n            location_id: The new location's ID\n            source_location: The source location it was generated from\n            entry_direction: The direction used to enter this location\n        \"\"\"\n        try:\n            # Get the new location from world state\n            world_state = self.state_manager.world_tracker.get_state()\n            if not world_state or location_id not in world_state.locations:\n                return\n            \n            new_location = world_state.locations[location_id]\n            location_type = new_location.state_flags.get(\"location_type\", \"unknown\")\n            \n            # Direction mapping for reverse connections\n            reverse_directions = {\n                \"north\": \"south\", \"south\": \"north\", \"east\": \"west\", \"west\": \"east\",\n                \"up\": \"down\", \"down\": \"up\", \"outside\": \"inside\", \"inside\": \"outside\",\n                \"loading\": \"return\", \"maintenance\": \"exit\"\n            }\n            \n            # Determine available directions (excluding the entry direction)\n            reverse_entry = reverse_directions.get(entry_direction, \"back\")\n            possible_directions = self._get_possible_directions(location_type)\n            \n            # Remove the reverse entry direction since that's already connected\n            available_directions = [d for d in possible_directions if d != reverse_entry]\n            \n            # Generate 1-3 additional exits randomly\n            import random\n            num_additional_exits = random.randint(1, min(3, len(available_directions)))\n            selected_directions = random.sample(available_directions, num_additional_exits)\n            \n            for direction in selected_directions:\n                # Create a \"placeholder\" connection that will be generated when explored\n                await self._create_placeholder_connection(location_id, direction, location_type)\n            \n            logger.info(f\"Generated {len(selected_directions)} additional exits for {new_location.name}\")\n            \n        except Exception as e:\n            logger.error(f\"Error generating additional exits: {e}\")\n    \n    def _get_possible_directions(self, location_type: str) -> list[str]:\n        \"\"\"\n        Get possible directions for a location type.\n        \n        Args:\n            location_type: The type of location\n            \n        Returns:\n            List of possible directions\n        \"\"\"\n        direction_sets = {\n            \"urban_street\": [\"north\", \"south\", \"east\", \"west\", \"inside\"],\n            \"industrial_district\": [\"north\", \"south\", \"east\", \"west\", \"inside\", \"down\"],\n            \"basement_access\": [\"north\", \"south\", \"east\", \"west\", \"down\"],\n            \"upper_floor\": [\"north\", \"south\", \"east\", \"west\", \"up\", \"down\"],\n            \"mechanical_room\": [\"north\", \"south\", \"east\", \"west\", \"maintenance\"],\n            \"sublevel\": [\"north\", \"south\", \"east\", \"west\", \"down\", \"maintenance\"],\n            \"industrial_zone\": [\"north\", \"south\", \"east\", \"west\", \"loading\"],\n            \"loading_dock\": [\"north\", \"south\", \"east\", \"west\", \"outside\"],\n            \"utility_tunnels\": [\"north\", \"south\", \"east\", \"west\", \"maintenance\", \"up\"],\n            \"roof_access\": [\"north\", \"south\", \"east\", \"west\", \"down\"],\n            \"building_interior\": [\"north\", \"south\", \"east\", \"west\", \"up\", \"down\"],\n            \"factory_interior\": [\"north\", \"south\", \"east\", \"west\", \"up\", \"down\"],\n            \"basement_corridor\": [\"north\", \"south\", \"east\", \"west\", \"down\"],\n            \"office_space\": [\"north\", \"south\", \"east\", \"west\", \"up\", \"down\"]\n        }\n        \n        return direction_sets.get(location_type, [\"north\", \"south\", \"east\", \"west\"])\n    \n    async def _create_placeholder_connection(\n        self, location_id: UUID, direction: str, location_type: str\n    ) -> None:\n        \"\"\"\n        Create a placeholder connection that will trigger generation when explored.\n        \n        Args:\n            location_id: The location to add the connection to\n            direction: The direction of the connection\n            location_type: The type of the source location\n        \"\"\"\n        try:\n            # Add the direction to the location's connections with a special placeholder UUID\n            # This will be detected in _handle_movement and trigger generation\n            world_state = self.state_manager.world_tracker.get_state()\n            if world_state and location_id in world_state.locations:\n                # Use a special UUID that indicates this needs generation\n                from uuid import UUID\n                placeholder_uuid = UUID('00000000-0000-0000-0000-000000000000')\n                \n                world_state.locations[location_id].connections[direction] = placeholder_uuid\n                \n                # Also add to database as a placeholder\n                from uuid import uuid4\n                async with self.db_pool.acquire() as conn:\n                    await conn.execute(\n                        \"\"\"\n                        INSERT INTO location_connections (id, from_location_id, to_location_id, direction, connection_type, requirements_json, is_visible)\n                        VALUES ($1, $2, $3, $4, $5, $6, $7)\n                        \"\"\",\n                        uuid4(), location_id, placeholder_uuid, direction, \"placeholder\", '{}', True\n                    )\n                \n                logger.info(f\"Created placeholder connection: {direction} from {location_id}\")\n                \n        except Exception as e:\n            logger.error(f\"Error creating placeholder connection: {e}\")\n\n    async def _generate_simple_location(
        self, source_location: Location, direction: str, location_type: str
    ) -> UUID | None:
        """Generate a simple new location connected to the source."""
        try:
            from uuid import uuid4
            from game_loop.state.models import Location as LocationModel
            
            # Create location based on type
            location_templates = {
                "urban_street": {
                    "name": "Abandoned Street",
                    "description": "A desolate urban street stretches before you, lined with empty storefronts and broken streetlights. Debris litters the asphalt, and the silence is unsettling. You can see more streets branching off in different directions, and in the distance, the hulking shapes of industrial buildings loom against the sky."
                },
                "industrial_district": {
                    "name": "Industrial District",
                    "description": "You emerge into a sprawling industrial complex filled with massive machinery and conveyor systems. Steam hisses from pipes overhead, and the air thrums with the sound of distant generators. Loading bays and factory entrances extend in multiple directions."
                },
                "basement_access": {
                    "name": "Basement Corridor",
                    "description": "A narrow concrete corridor extends into darkness, lit by flickering fluorescent strips. You can hear the hum of electrical systems and the drip of water from unseen leaks. Multiple passages branch off, leading deeper into the building's underground network."
                },
                "upper_floor": {
                    "name": "Upper Office Floor",
                    "description": "This higher floor contains executive offices and conference rooms, all abandoned but better preserved than the lower levels. Large windows show the city beyond, while doors lead to more office spaces and what appears to be a mechanical area."
                },
                "mechanical_room": {
                    "name": "Mechanical Room",
                    "description": "A room filled with building systems: massive HVAC units, electrical panels, and cooling systems. The mechanical sounds are louder here, and you can see maintenance walkways leading to other parts of the building's infrastructure."
                },
                "sublevel": {
                    "name": "Sub-Basement",
                    "description": "This lower level contains building utilities and storage areas. The ceiling is lower here, supported by concrete pillars. You can see tunnels leading in various directions, possibly connecting to other buildings or the city's utility network."
                },
                "industrial_zone": {
                    "name": "Industrial Processing Area",
                    "description": "A large space filled with industrial equipment and processing machinery. Conveyor belts and assembly stations stretch across the floor. Exits lead to other processing areas and what appears to be a shipping district."
                },
                "loading_dock": {
                    "name": "Loading Dock",
                    "description": "A concrete platform where trucks once loaded and unloaded cargo. Large rolling doors face outward toward what was once a busy industrial area. You can see truck bays and pathways leading to other logistics areas."
                },
                "utility_tunnels": {
                    "name": "Utility Tunnels",
                    "description": "Underground maintenance tunnels that run beneath the building complex. Pipes and electrical conduits line the walls, and you can hear the echo of your footsteps. The tunnels branch in multiple directions, likely connecting to other buildings."
                },
                "roof_access": {
                    "name": "Rooftop Access",
                    "description": "You emerge onto a rooftop area with HVAC equipment and communication arrays. The view shows the surrounding industrial district and urban landscape. Maintenance walkways connect to other building sections."
                }
            }
            
            template = location_templates.get(location_type, {
                "name": "Unknown Area",
                "description": "A mysterious area that defies easy description."
            })
            
            new_location_id = uuid4()
            
            # Add to database via connection pool
            async with self.db_pool.acquire() as conn:
                await conn.execute(
                    """
                    INSERT INTO locations (id, name, short_desc, full_desc, location_type, is_dynamic, created_by, state_json)
                    VALUES ($1, $2, $3, $4, $5, $6, $7, $8)
                    """,
                    new_location_id,
                    template["name"],
                    f"A dynamically generated {location_type.replace('_', ' ')}",
                    template["description"],
                    "dynamic",
                    True,  # is_dynamic
                    "dynamic_generation",
                    "{}"
                )
            
            # Add to world state
            world_state = self.state_manager.world_tracker.get_state()
            if world_state:
                new_location = LocationModel(
                    location_id=new_location_id,
                    name=template["name"],
                    description=template["description"]
                )
                world_state.locations[new_location_id] = new_location
            
            logger.info(f"Generated new location: {template['name']} ({new_location_id})")
            return new_location_id
            
        except Exception as e:
            logger.error(f"Error generating simple location: {e}")
            return None

    async def _add_connection(self, from_location_id: UUID, to_location_id: UUID, direction: str) -> None:
        """Add a bidirectional connection between two locations."""
        try:
            # Direction mapping for reverse connections
            reverse_directions = {
                "north": "south", "south": "north", "east": "west", "west": "east",
                "up": "down", "down": "up", "outside": "inside", "inside": "outside",
                "loading": "return", "maintenance": "exit"
            }
            
            reverse_direction = reverse_directions.get(direction, "back")
            
            from uuid import uuid4
            
            # Add to database
            async with self.db_pool.acquire() as conn:
                # Forward connection
                await conn.execute(
                    """
                    INSERT INTO location_connections (id, from_location_id, to_location_id, direction, connection_type, requirements_json, is_visible)
                    VALUES ($1, $2, $3, $4, $5, $6, $7)
                    """,
                    uuid4(), from_location_id, to_location_id, direction, "path", "{}", True
                )
                
                # Reverse connection
                await conn.execute(
                    """
                    INSERT INTO location_connections (id, from_location_id, to_location_id, direction, connection_type, requirements_json, is_visible)
                    VALUES ($1, $2, $3, $4, $5, $6, $7)
                    """,
                    uuid4(), to_location_id, from_location_id, reverse_direction, "path", "{}", True
                )
            
            # Add to world state
            world_state = self.state_manager.world_tracker.get_state()
            if world_state:
                if from_location_id in world_state.locations:
                    world_state.locations[from_location_id].connections[direction] = to_location_id
                if to_location_id in world_state.locations:
                    world_state.locations[to_location_id].connections[reverse_direction] = from_location_id
            
            logger.info(f"Added connection: {direction} ({from_location_id} -> {to_location_id})")
            
        except Exception as e:
            logger.error(f"Error adding connection: {e}")

    async def _auto_save_game(self) -> None:
        """Auto-save the current game state."""
        if self.state_manager.get_current_session_id():
            try:
                await self.state_manager.save_game()
                self.console.print("[dim]Game auto-saved.[/dim]")
            except Exception as e:
                logger.error(f"Auto-save failed: {e}")
                # Don't show error to user as this is automatic
